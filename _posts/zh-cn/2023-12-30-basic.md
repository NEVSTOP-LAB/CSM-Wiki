---
title: 基础用法
author: nevstop
date: 2023-12-30
layout: post
lang: zh-cn
page_id: basic-of-csm
toc: true
---

## Step1. 创建基于 CSM 的可重用模块

创建一个可重用模块通常不需要与其他模块进行消息交互；它只需要提供外部接口和发布模块的状态变化。因此，只要明确描述了这两个方面，就可以在不了解内部实现细节的情况下，调用可重用模块。

在CSM模块中，所有 case 分支都可以被视为调用的消息，但建议使用 API 分组作为外部接口。当发送状态更新时，通过发送 Status 或 Interrupt Status 来通知外部模块内部的状态变化。

可参考范例 ***/Example/1. Create a reusable module***
![img](https://nevstop-lab.github.io/CSM-Wiki/assets/img/slides/Baisic-1.Create%20Reuse%20Module(CN).png)

### 模块设计原则

设计一个良好的可重用CSM模块，应遵循以下原则：

#### 1. 单一职责原则
每个模块应该只负责一个明确的功能领域。例如：
- **数据采集模块**：只负责数据采集相关功能
- **文件操作模块**：只负责文件读写操作
- **通讯模块**：只负责网络或串口通讯

#### 2. 接口清晰原则
- **API命名规范**：使用清晰的命名，如`API: StartAcquisition`、`API: StopAcquisition`
- **参数明确**：每个API的参数含义清晰，类型明确
- **返回值一致**：相同类型的操作返回值格式应保持一致

#### 3. 独立性原则
- **避免直接依赖**：不要在模块内部硬编码其他模块名称
- **使用广播解耦**：通过广播机制与外部交互，而不是直接调用
- **配置灵活**：通过Attribute或初始化参数配置模块行为

#### 4. 错误处理原则
- **完善的错误处理**：实现"Error Handler"状态，妥善处理各类错误
- **错误广播**：通过"Error Occurred"广播通知外部错误情况
- **错误恢复**：考虑错误后的恢复机制

### API接口设计

#### API命名规范

建议使用以下命名规范：

1. **使用"API:"前缀**：明确标识这是外部接口
   ```
   API: Initialize
   API: Configure
   API: Start
   API: Stop
   API: GetStatus
   ```

2. **动词开头**：使用动词描述操作
   ```
   API: Read      // 读取数据
   API: Write     // 写入数据
   API: Connect   // 建立连接
   API: Disconnect // 断开连接
   ```

3. **语义清晰**：避免缩写和模糊词汇
   ```
   推荐：API: StartAcquisition
   不推荐：API: StrtAcq
   ```

#### API分类

根据功能将API分组：

1. **生命周期API**：
   - `API: Initialize` - 初始化模块
   - `API: Start` - 启动模块运行
   - `API: Stop` - 停止模块运行
   - `API: Cleanup` - 清理资源

2. **配置API**：
   - `API: SetParameter` - 设置参数
   - `API: GetParameter` - 获取参数
   - `API: LoadConfig` - 加载配置
   - `API: SaveConfig` - 保存配置

3. **功能API**：
   - `API: Execute` - 执行特定功能
   - `API: Query` - 查询状态或数据
   - `API: Update` - 更新内部状态

#### API文档化

为每个API提供清晰的文档说明：

```labview
// API: StartAcquisition
// 功能：启动数据采集
// 参数：
//   - SampleRate: 采样率(Hz)，范围1-10000
//   - Channels: 通道列表，逗号分隔，如"AI0,AI1,AI2"
// 返回：
//   - Success: 采集已启动
//   - Error: 错误信息（如果启动失败）
// 示例：
//   API: StartAcquisition >> 1000,AI0,AI1 -@ DAQModule
```

### 状态广播设计

#### 广播命名规范

1. **使用描述性名称**：
   ```
   DataReady           // 数据准备就绪
   ConnectionEstablished  // 连接已建立
   ErrorOccurred       // 发生错误
   TaskCompleted       // 任务完成
   ```

2. **状态变化广播**：
   ```
   StateChanged >> NewState    // 状态改变
   ValueUpdated >> NewValue    // 值更新
   ConfigModified >> ConfigName // 配置修改
   ```

#### 广播优先级选择

- **信号广播(Status)**：用于常规状态通知，不紧急
  ```
  DataReady >> Data -> <status>
  ```

- **中断广播(Interrupt)**：用于紧急通知，需要立即处理
  ```
  EmergencyStop >> Reason -> <interrupt>
  ```

### 模块测试方法

#### 单元测试

1. **使用调试控制台**：
   - 打开CSM调试控制台
   - 选择要测试的模块
   - 逐个测试每个API
   - 验证返回值是否符合预期

2. **创建测试脚本**：
   ```
   // 测试初始化
   API: Initialize >> DefaultConfig -@ TestModule
   // 测试配置
   API: SetParameter >> SampleRate,1000 -@ TestModule
   // 测试启动
   API: Start -@ TestModule
   // 测试停止
   API: Stop -@ TestModule
   ```

3. **错误场景测试**：
   - 测试无效参数
   - 测试异常顺序调用
   - 测试超时场景

#### 集成测试

1. **消息流测试**：
   - 使用全局日志窗口监控消息流
   - 验证消息传递的时序
   - 检查是否有消息丢失

2. **状态订阅测试**：
   - 创建测试模块订阅广播
   - 验证广播是否正确触发
   - 检查订阅的参数传递

3. **性能测试**：
   - 测试高频消息处理能力
   - 测试长时间运行的稳定性
   - 监控内存和资源使用

### 模块文档化

#### 必要文档内容

1. **模块概述**：
   - 模块功能说明
   - 适用场景
   - 依赖关系

2. **API列表**：
   - 所有公开API及其说明
   - 参数格式和返回值
   - 使用示例

3. **广播列表**：
   - 所有广播及其触发条件
   - 参数说明
   - 订阅示例

4. **Attribute列表**：
   - 所有可用属性
   - 数据类型
   - 读写权限

5. **使用示例**：
   - 基本使用流程
   - 常见场景示例
   - 最佳实践建议

### 模块版本管理

1. **版本号规则**：使用语义化版本号（如v1.2.3）
   - 主版本号：重大接口变更
   - 次版本号：新增功能，向后兼容
   - 修订号：Bug修复

2. **变更日志**：记录每个版本的变更内容

3. **向后兼容**：保持API接口的稳定性，避免破坏性变更

### 模块名称命名规则

一个有效的CSM模块名称是一个字符串，不应包含以下任何特殊字符: `~!@%^&*()\[\]{}+=|\\/?'"<>,.\t\r\n`。这些字符是CSM框架内保留用于其他目的的关键字。

详细的命名规则请参考[CSM基本概念](./2023-12-28-concepts.html#csm模块命名规则)。

### 系统级模块

系统级(SystemLevel)模块系统级模块的名称前会添加一个"."作为前缀，标记为系统级模块。功能上与普通模块无异，可以进行消息通讯和状态订阅。他们之间的区别在于系统级的模块，不会自动被列出在活动模块列表中。这样在普通的逻辑调度中，系统级模块不会被直接调用，只能通过显式的消息发送，才能被触发。

因此系统级模块通常用于实现一些全局的后台功能，例如 TCP程序中的调度模块等。

更多关于系统级模块的信息，请参考[CSM高级模式与特性](./2023-12-31-advance.html#系统级模块)。

### CSM Attribute

CSM Attribute是CSM框架内用于存储模块配置的一种机制。它被用于:
- 提供一种无需消息访问的配置方法，外部通过模块名称、属性名称、数据类型即可直接读写模块的属性值。
- 提供一种Worker模式、Chain模式模块内部节点数据共享的机制。不同的节点共享同一个Attribute空间，节点可以通过读写Attribute来实现数据共享。

详细的Attribute使用方法，请参考[CSM基本概念](./2023-12-28-concepts.html#csm属性csm-attribute)。

## Step2. 在CSM框架中调用模块

当调用者也是CSM模块时，模块之间的通信完全依赖于消息字符串队列操作。你可以使用 **Build Message with Arguments++.vi** 函数生成Message字符串，或者，如果你熟悉规则，直接编写用于描述通讯的字符串。

### CSM消息语法规则

``` c
#CSM 状态语法
    // 本地消息示例
    DoSth: DoA >> 参数

    // 同步调用示例
    API: xxxx >> 参数 -@ TargetModule

    // 异步调用示例
    API: xxxx >> 参数 -> TargetModule

    // 无应答异步调用示例
    API: xxxx >> 参数 ->| TargetModule

    // 广播正常状态：
    Status >> StatusArguments -><status>

    // 广播中断状态：
    Interrupt >> StatusArguments -><interrupt>

    // 将源模块的状态注册到处理程序模块
    Status@Source Module >> Handler Module@Handler Module -><register>

    // 取消注册源模块的状态
    Status@Source Module >> Handler Module -><unregister>

#CSM 注释
    // 要添加注释，请使用 "//"，右边的所有文本将被忽略。
    UI: Initialize // 初始化 UI
    // Another comment line

```

### CSM框架内调用最佳实践

1. **使用API构建函数**：对于复杂消息，使用Build Message系列VI减少错误
2. **善用注释**：在消息字符串中添加注释，提高可读性
3. **统一消息格式**：团队内统一消息命名和参数格式
4. **错误处理**：实现Response和Async Response状态处理返回值
5. **超时设置**：合理设置同步调用的超时时间

### 消息调用流程

#### 同步调用流程
1. 构建同步消息：`API: Operation >> Args -@ TargetModule`
2. 将消息加入状态队列
3. Parse State Queue++.vi发送消息并等待
4. 接收响应，进入"Response"状态处理

#### 异步调用流程
1. 构建异步消息：`API: Operation >> Args -> TargetModule`
2. 将消息加入状态队列
3. Parse State Queue++.vi发送消息后立即进入"Async Message Posted"
4. 继续执行其他状态
5. 收到响应时进入"Async Response"状态处理

可参考范例 ***/Example/2. Caller is CSM Scenario***.
![img](https://nevstop-lab.github.io/CSM-Wiki/assets/img/slides/Baisic-2.Call%20in%20CSM%20Framework(CN).png)

## Step3. 在其他框架中调用CSM模块

当调用者不是CSM模块（如使用DQMH、Actor Framework或传统状态机），可以使用CSM提供的API与CSM模块通讯。

### 核心调用API

#### 1. CSM - Post Message.vi
用于从非CSM代码中发送异步消息（无返回）。

**使用场景**：
- 通知型操作
- 不需要等待结果
- 单向数据传递

**使用示例**：
```labview
// 从DQMH模块发送消息到CSM模块
CSM - Post Message.vi
  - State: "API: ProcessData"
  - Arguments: "DataString"
  - Target Module: "DataProcessor"
```

#### 2. CSM - Send Message and Wait for Reply.vi
用于从非CSM代码中发送同步消息（等待返回）。

**使用场景**：
- 需要立即获取结果
- RPC风格的调用
- 配置和查询操作

**使用示例**：
```labview
// 查询CSM模块状态
CSM - Send Message and Wait for Reply.vi
  - State: "API: GetStatus"
  - Arguments: ""
  - Target Module: "StatusModule"
  - Timeout: 5000ms
  - Response: 返回的状态信息
```

**注意事项**：
- 设置合适的超时时间
- 处理可能的超时错误
- 避免在事件结构中阻塞

#### 3. 订阅CSM模块状态

通过用户事件订阅CSM模块的状态变化：

```labview
// 步骤1：注册订阅
CSM - Register Broadcast.vi
  - CSM Name: "SubscriberModule"
  - Source CSM Name: "DataModule"
  - Trigger: "DataReady"
  - API: "ProcessData"

// 步骤2：在事件结构中处理
Event Structure
  - Case: "ProcessData" Event
  - 处理收到的数据
```

### 非CSM框架集成模式

#### 模式1：命令-通知模式
外部框架发送命令，订阅CSM的完成通知：

```
外部框架 --Post Message--> CSM模块
          <--Broadcast-- (完成通知)
```

#### 模式2：同步查询模式
外部框架同步调用CSM获取数据：

```
外部框架 --Send & Wait--> CSM模块
          <--Response-- (返回数据)
```

#### 模式3：事件驱动模式
外部框架订阅CSM的状态变化事件：

```
外部框架 --Register--> CSM模块
         <--Event-- (状态变化)
```

### 集成最佳实践

1. **避免阻塞**：在事件结构中使用Post而不是Send & Wait
2. **使用适配器**：创建适配器模块转换消息格式
3. **错误处理**：实现完整的错误处理机制
4. **超时保护**：所有同步调用都应设置超时
5. **状态同步**：通过订阅机制保持状态同步

可参考范例 ***/Example/3. Caller is Other Framework Scenario***.
![img](https://nevstop-lab.github.io/CSM-Wiki/assets/img/slides/Baisic-3.Call%20in%20other%20Framework(CN).png)

## Step4. CSM参数传递

CSM 只支持 STRING TYPE 作为参数，但是需要传输的数据种类繁多。因此，对参数的支持至关重要。本节详细介绍CSM的参数传递机制和各种参数类型的使用方法。

### 参数传递的特殊性

#### 为什么只支持字符串？

1. **灵活性**：字符串可以表示任意数据类型
2. **可扩展性**：易于添加新的编码方案
3. **调试友好**：字符串格式易于在日志中查看
4. **跨模块兼容**：不同模块间无需关心内部数据类型

#### 编码-解码机制

CSM的参数传递采用编码-解码模式：

```mermaid
graph LR
    A[发送方数据] --> B[编码为字符串]
    B --> C[CSM消息传递]
    C --> D[接收方解码]
    D --> E[恢复原始数据]
```

### 参数类型对比

下表列出了当前支持不同数据类型的方法，其中一些是 CSM 内置的，而其他一些则需要安装额外的支持插件。

| 参数类型 | 类型 | 适用场景 | 性能 | 描述 |
|---|---|---|---|---|
| 纯字符串 | 内置 | 简单文本 | ⭐⭐⭐⭐⭐ | 直接传递，无需编解码 |
| SAFESTR | 内置 | 包含特殊字符的字符串 | ⭐⭐⭐⭐ | 特殊字符转换为%[HEXCODE] |
| HEXSTR | 内置 | 复杂数据类型 | ⭐⭐⭐ | 任意数据类型转十六进制字符串 |
| ERRSTR | 内置 | 错误传递 | ⭐⭐⭐⭐ | 专门用于传递LabVIEW错误簇 |
|[MassData](https://github.com/NEVSTOP-LAB/CSM-MassData-Parameter-Support) |插件| 大数组、波形 | ⭐⭐⭐⭐⭐ | 循环缓冲区，高效传递大数据 |
|[API Arguments](https://github.com/NEVSTOP-LAB/CSM-API-String-Arugments-Support) |插件| 多参数API | ⭐⭐⭐⭐ | 支持将纯字符串作为CSM API参数 |
|[INI Static Variable](https://github.com/NEVSTOP-LAB/CSM-INI-Static-Variable-Support)|插件| 配置变量 | ⭐⭐⭐⭐ | 提供${variable}支持 |

### 内置参数类型详解

#### 1. 纯字符串（Plain String）

最简单直接的方式，适用于简单文本数据。

**适用场景**：
- 文件路径
- 简单配置值
- 状态描述
- 命令名称

**使用示例**：
```labview
// 传递文件路径
API: LoadFile >> C:\Data\test.txt -@ FileModule

// 传递配置值
API: SetSampleRate >> 1000 -@ DAQModule
```

**注意事项**：
- 不能包含CSM关键字（如`->`、`-@`等）
- 不能包含换行符和回车符
- 如果包含特殊字符，使用SAFESTR

#### 2. 安全字符串（SAFESTR）

将CSM关键字转换为安全格式，避免解析错误。

**转换规则**：
- `->` 转换为 `%3E%3E`
- `-@` 转换为 `%2D%40`
- `\n` 转换为 `%0A`
- 其他特殊字符类似处理

**使用API**：
- **编码**：`CSM - Make String Arguments Safe.vi`
- **解码**：`CSM - Revert Arguments-Safe String.vi`

**使用示例**：
```labview
// 编码
输入: "Value -> Target"
CSM - Make String Arguments Safe.vi
输出: "<SAFESTR>Value %2D%3E Target"

// 解码
输入: "<SAFESTR>Value %2D%3E Target"
CSM - Revert Arguments-Safe String.vi
输出: "Value -> Target"
```

**最佳实践**：
- 对用户输入的字符串进行安全编码
- 在日志显示时解码，提高可读性
- 不确定是否包含特殊字符时，使用SAFESTR

#### 3. 十六进制字符串（HEXSTR）

将任意LabVIEW数据类型转换为十六进制字符串，支持无损传递复杂数据。

**转换过程**：
1. 数据 → 变体(Variant)
2. 变体 → 十六进制字符串
3. 添加`<HEXSTR>`标记

**使用API**：
- **编码**：`CSM - Convert Data to HexStr.vi`
- **解码**：`CSM - Convert HexStr to Data.vi`

**使用示例**：
```labview
// 编码数组
输入: [1.0, 2.5, 3.7] (DBL Array)
CSM - Convert Data to HexStr.vi
输出: "<HEXSTR>000000000000F03F..."

// 解码
输入: "<HEXSTR>000000000000F03F..."
CSM - Convert HexStr to Data.vi
输出: [1.0, 2.5, 3.7] (Variant)
需要: Variant to Data 转换为目标类型
```

**适用场景**：
- 传递数组（数值、布尔、字符串数组等）
- 传递簇(Cluster)
- 传递波形数据
- 传递枚举和类型定义

**性能考虑**：
- 编解码有一定开销
- 数据量大时考虑使用MassData
- 小于1KB的数据使用HEXSTR是合适的

#### 4. 错误字符串（ERRSTR）

专门用于传递LabVIEW错误簇的格式。

**格式**：
```
<ERRSTR>[Error: error-code] error-description
```

**使用API**：
- **编码**：`CSM - Convert Error to Argument.vi`
- **解码**：`CSM - Convert Argument to Error.vi`

**使用示例**：
```labview
// 编码错误
输入: Error 1 - "File not found"
CSM - Convert Error to Argument.vi
输出: "<ERRSTR>[Error: 1] File not found"

// 解码错误
输入: "<ERRSTR>[Error: 1] File not found"
CSM - Convert Argument to Error.vi
输出: Error Cluster {status: TRUE, code: 1, source: "File not found"}
```

**应用场景**：
- 错误传播
- 远程错误报告
- 错误日志记录

### 参数处理工具VI

CSM提供了一系列参数处理工具VI：

#### 1. CSM - Argument Type.vi
从编码后的参数字符串中提取参数的编码类型标记。

**功能**：识别参数类型（SAFESTR、HEXSTR、ERRSTR等）

**使用示例**：
```labview
输入: "<HEXSTR>0123456789ABCDEF"
CSM - Argument Type.vi
输出: "HEXSTR"
```

#### 2. CSM - Keywords.vi
列出CSM消息中的所有关键字及其%Hex格式。

**功能**：提供关键字参考表

#### 3-4. Safe String 编解码
- `CSM - Make String Arguments Safe.vi`：编码
- `CSM - Revert Arguments-Safe String.vi`：解码

#### 5-6. HEXSTR 编解码
- `CSM - Convert Data to HexStr.vi`：编码
- `CSM - Convert HexStr to Data.vi`：解码

#### 7-8. ERRSTR 编解码
- `CSM - Convert Error to Argument.vi`：编码
- `CSM - Convert Argument to Error.vi`：解码

![table](https://nevstop-lab.github.io/CSM-Wiki/assets/img/slides/Baisic-4.Arguments(CN).png)

### 参数使用场景指南

#### 场景1：传递配置参数
```labview
// 简单值：直接传递
API: SetValue >> 100 -@ Module

// 多个参数：使用分隔符
API: Configure >> 1000,100,True -@ Module

// 或使用API Arguments插件
API: Configure("SampleRate", "1000", "Samples", "100") -@ Module
```

#### 场景2：传递数据数组
```labview
// 小数组：使用HEXSTR
Data Array -> HEXSTR
API: ProcessData >> <HEXSTR>... -@ Module

// 大数组：使用MassData
Data Array -> MassData Buffer
API: ProcessData >> <MassData>StartAddr,Length -@ Module
```

#### 场景3：传递错误信息
```labview
// 使用ERRSTR
Error Cluster -> ERRSTR
API: ReportError >> <ERRSTR>... -@ LogModule

// 或通过Error Occurred广播
Error Occurred >> <ERRSTR>... -> <status>
```

#### 场景4：传递文件路径
```labview
// 简单路径：直接传递
API: LoadFile >> C:\Data\file.txt -@ Module

// 包含特殊字符：使用SAFESTR
Path with "->" -> SAFESTR
API: LoadFile >> <SAFESTR>... -@ Module
```

### 参数传递最佳实践

#### 1. 选择合适的编码方式
- **简单数据**：纯字符串
- **包含特殊字符**：SAFESTR
- **复杂数据**：HEXSTR或MassData
- **错误信息**：ERRSTR

#### 2. 性能优化
- 小数据（<1KB）：HEXSTR
- 大数据（>1KB）：MassData
- 频繁传递：考虑使用CSM Attribute共享数据

#### 3. 可维护性
- 统一参数格式和命名
- 添加参数类型标记
- 提供清晰的文档说明
- 使用类型检查避免错误

#### 4. 调试技巧
- 使用全局日志查看参数内容
- HEXSTR可以还原查看原始数据
- 添加参数验证代码
- 记录参数解码失败的情况

### CSM消息关键字

CSM保留的关键字（不能在参数中直接使用）：

```
->    异步调用符号
->|   异步无返回符号
-@    同步调用符号
-&    （保留）
<-    响应符号
\r    回车符
\n    换行符
//    注释符号
>>    参数分隔符
>>>   （多参数分隔符）
>>>>  （多参数分隔符）
;     （保留）
,     （保留）
```

如果参数中需要使用这些字符，必须使用SAFESTR编码。

### 参数传递完整示例

#### 示例1：传递配置数据
```labview
// 发送方
Config Cluster {
    SampleRate: 1000
    Channels: "AI0,AI1"
    TriggerLevel: 2.5
}
↓
CSM - Convert Data to HexStr.vi
↓
API: Configure >> <HEXSTR>... -@ DAQModule

// 接收方
Arguments = "<HEXSTR>..."
↓
CSM - Convert HexStr to Data.vi
↓
Variant to Data (Config Cluster)
↓
使用配置数据
```

#### 示例2：错误传播
```labview
// 模块A发生错误
Error Cluster {code: 1, source: "Cannot open file"}
↓
CSM - Convert Error to Argument.vi
↓
Error Occurred >> <ERRSTR>... -> <status>

// 模块B订阅错误
订阅: Error Occurred@ModuleA >> HandleError
↓
HandleError状态接收到 "<ERRSTR>..."
↓
CSM - Convert Argument to Error.vi
↓
处理错误
```

## 总结

通过本章的学习，你应该掌握了：

1. **创建可重用模块**：遵循设计原则，提供清晰的API和广播接口
2. **CSM框架内调用**：使用消息字符串或Build Message API
3. **其他框架调用**：使用Post Message和Send & Wait API
4. **参数传递**：选择合适的参数编码方式，实现灵活的数据传递

这些基础知识是开发CSM应用的基石，掌握这些内容后，你可以创建出模块化、可重用、易维护的LabVIEW应用系统。

更多高级特性，请参考：
- [CSM高级模式与特性](./2023-12-31-advance.html)
- [CSM模块间通讯](./2023-12-29-communication.html)
- [CSM调试与开发工具](./2024-01-03-csm-Tools.html)
