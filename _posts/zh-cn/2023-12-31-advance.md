---
title: CSM高级模式与特性
author: nevstop
date: 2023-12-31
layout: post
lang: zh-cn
page_id: advance-of-csm
toc: true
---

CSM框架提供了多种高级模式和特性，用于满足复杂应用场景的需求。本文介绍CSM的错误处理机制、系统级模块、子模块、工作者模式、责任链模式以及多循环支持等高级特性。

## 内置的错误处理机制

CSM框架提供了完善的错误处理机制，用于捕获和处理模块运行过程中出现的各类错误。每个CSM模块在发生错误时，会自动广播`Error Occurred`状态，任何订阅了该状态的模块都可以捕获并处理这些错误。

### 工作原理

CSM的错误处理机制基于状态机的错误流和广播机制实现：

1. 当CSM模块中出现错误时，错误会通过错误线传递到Parse State Queue++ VI
2. 错误信息会触发CSM模块自动转入`Error Handler`状态
3. 在`Error Handler`状态中，模块会将错误信息通过`Error Occurred`广播发送出去
4. 任何订阅了该模块`Error Occurred`状态的模块，都会收到错误通知并进行处理

### 错误类型

CSM框架定义了以下几种常见的错误类型：

- **Critical Error**: 严重错误，通常是CSM框架层面的错误，如模块名称重复。模块会进入`Critical Error`状态并停止运行
- **No Target Error**: 消息发送时目标模块为空字符串
- **Target Error**: 消息发送的目标模块不存在
- **Target Timeout Error**: 同步消息发送后，在超时时间内未收到响应
- **Unhandled State Error**: 状态机中出现未定义的状态

### 全局错误处理

通过在主程序中订阅所有模块的`Error Occurred`广播事件，可以实现全局的错误处理机制：

```
Error Occurred@* >> Error Handler -><register>
```

这样，当任何CSM子模块抛出`Error Occurred`状态时，都会触发主程序的`Error Handler`状态进行集中处理。这种机制特别适合：

- 统一的错误日志记录
- 全局的错误提示界面
- 错误统计和分析
- 根据错误类型采取不同的恢复策略

### 应用示例

可参考范例 ***/Example/4. Advance Examples/1. Global Error Handling***

## 系统级模块

系统级模块是一种特殊的CSM模块，用于实现后台服务和系统功能。系统级模块的名称以`.`开头，在默认情况下不会被`CSM - List Modules VI`列出。

### 设计目的

系统级模块的设计目的是将系统后台服务与业务模块分离：

- 后台服务模块（如日志服务、通讯调度等）不应该被业务逻辑直接干扰
- 统一处理业务模块时（如批量发送退出消息），可以排除系统模块
- 提供更清晰的架构层次划分

### 命名规则

系统级模块的命名必须以`.`开头，例如：

- `.MainApp` - 主应用程序循环
- `.BackgroundTask` - 后台任务
- `.Logger` - 日志服务
- `.TCPDispatcher` - TCP调度器

### 使用方法

使用`CSM - Mark As System-Level Module.vi`可以方便地生成系统级模块名称，或者直接在模块名称前添加`.`。

系统级模块的其他CSM功能与普通模块完全相同，包括消息通讯、状态订阅等。唯一区别在于列表展示和管理层面。

### 典型应用场景

将主程序命名为`.MainApp`，这样在需要退出所有业务模块时，可以使用：

```labview
Macro: Exit -> CSM - List Modules VI的结果
```

这样可以退出所有普通业务模块，而不会影响`.MainApp`主程序的运行。

### 参考范例

可参考范例：`0. Base Concepts\7. System-Level Module.vi`

## 子模块

CSM通过模块名称中的`.`实现逻辑分组，虽然没有严格意义上的父子层级关系，但可以通过命名来表达模块间的逻辑关系。

### 工作原理

CSM中的子模块仅仅是命名上的约定，从运行角度看每个模块都是独立的：

- `ModuleA`和`ModuleA.SubmoduleB`是两个独立的模块
- 它们之间没有特殊的依赖或控制关系
- 可以使用`CSM - List Submodules VI`获取某个前缀下的所有模块

### 应用场景

子模块命名适用于以下场景：

1. **逻辑分组**: 将相关的模块分组，如`UI.MainWindow`、`UI.SettingsDialog`
2. **虚拟分组**: 父模块可以不实际存在，如`DAQ.Channel1`、`DAQ.Channel2`
3. **功能模块化**: 如`System.Logger`、`System.Config`、`System.Monitor`

### 与高级模式结合

子模块命名可以与其他高级模式结合使用：

- 系统级子模块：`.System.Logger`
- 工作者模式子模块：`Worker.Task#`
- 责任链模式子模块：`Chain.Handler$1`

## 工作者模式

工作者模式（Worker Mode）是CSM框架中的一种高级模式，通过实例化多个相同功能的模块并共享消息队列，实现任务的并发处理。这种模式特别适合需要并行处理大量相似任务的场景。

### 核心概念

在工作者模式下，多个CSM实例共同组成一个逻辑上的复合模块：

- **Worker Agent（工作者代理）**: 从外部看到的模块名称，如`Downloader`
- **Worker（工作者）**: 每个实际的CSM实例，如`Downloader#59703F3AD837`、`Downloader#106A470BA5EC`

### 工作原理

1. **命名机制**: 申请模块名称时在名称后添加`#`，CSM框架会为每个实例生成唯一的标识符
2. **消息队列共享**: 所有Worker共享同一个消息队列
3. **公平调度**: 空闲的Worker从共享队列中获取消息进行处理
4. **透明性**: 外部调用者只需要与Worker Agent通讯，无需关心内部有多少Worker

### 行为特性

从外部调用者的角度：

```labview
// 申请模块名称为 module#，实例化2个Worker
// 实际的Worker名称可能为:
//   - module#59703F3AD837
//   - module#106A470BA5EC

// 发送消息只需使用Worker Agent名称
API: DoTask >> arguments -@ module  // 空闲的Worker将处理此同步消息
API: DoTask >> arguments -> module   // 空闲的Worker将处理此异步消息
```

### 典型应用场景

工作者模式适用于以下场景：

1. **并发服务**: 类似10086客服系统，多个客服人员共同处理来电
2. **并发下载**: 多个下载线程并发处理下载任务
3. **并发编译**: 编译器使用多个Worker并发编译不同的源文件
4. **TCP服务器**: 每个Worker处理一个客户端连接
5. **数据处理**: 多个Worker并发处理数据分析任务

### 实现步骤

1. **标记为Worker模式**: 使用`CSM - Mark As Worker Module.vi`在模块名称后添加`#`
2. **启动多个实例**: 异步调用多个相同的Worker模块
3. **发送任务消息**: 向Worker Agent发送消息，系统自动分配给空闲的Worker
4. **退出处理**: 向Worker Agent发送`Macro: Exit`消息，所有Worker会依次退出

### 使用API

`CSM - Mark As Worker Module.vi`用于生成工作者模式的模块名称：

- **输入**: CSM Name - 如`Downloader`
- **输出**: CSM Name (Marked As Worker) - 如`Downloader#`

### 注意事项

- 不能直接向单个Worker发送消息，必须通过Worker Agent
- Worker之间不共享数据，每个Worker独立处理任务
- 适合无状态或状态独立的任务处理
- 带用户界面的模块不适合使用工作者模式

### 参考范例

可参考范例：`4. Advance Examples\1. Action Workers Example`

## 责任链模式

责任链模式（Chain of Responsibility Mode）是CSM框架中的另一种高级模式，通过将多个CSM模块按顺序组织成链条，实现消息的顺序传递和处理。

### 核心概念

在责任链模式下，多个CSM实例按顺序组成一个处理链：

- **Chain（责任链）**: 从外部看到的模块名称，如`Handler`
- **Chain Node（链节点）**: 每个实际的CSM实例，如`Handler$1`、`Handler$2`、`Handler$3`

### 工作原理

1. **命名机制**: 模块名称后添加`$`和整数编号，如`Handler$1`、`Handler$2`
2. **顺序处理**: 消息按照节点编号从小到大的顺序传递
3. **能力过滤**: 每个节点只处理自己能力范围内的消息
4. **就近处理**: 消息被第一个能处理它的节点处理后，不再向后传递
5. **错误返回**: 如果整个链条都无法处理某个消息，返回错误

### 行为特性

```labview
// 申请模块名称为 Handler$，实例化4个节点:
//   - Handler$1 (链首)
//   - Handler$2
//   - Handler$3  
//   - Handler$4 (链尾)

// 假设Handler$3和Handler$4都能处理"API: Process"
API: Process >> arguments -@ Handler
// 消息将被Handler$3处理，Handler$4不会收到
```

### 典型应用场景

责任链模式适用于以下场景：

1. **权限审批**: 按照职位层级，具有相应权限的人员直接审批，无需继续传递
   - 普通员工请假：组长审批
   - 组长请假：部门经理审批
   - 部门经理请假：总经理审批

2. **功能拼接**: 不同节点实现不同功能，通过链条组合实现完整功能
   - 数据处理链：验证 -> 转换 -> 存储
   - 消息处理链：解析 -> 路由 -> 执行

3. **功能覆盖**: 实现类似OOP中的重载机制
   - 基础功能节点：提供默认实现
   - 扩展功能节点：覆盖特定场景的处理

4. **灵活配置**: 通过动态调整节点顺序和能力，改变系统行为

### 实现步骤

1. **定义节点能力**: 为每个节点定义能处理的消息（通常在模块的case结构中）
2. **标记为Chain模式**: 使用`CSM - Mark As Chain Module.vi`生成带编号的节点名称
3. **启动节点**: 按顺序启动各个链节点
4. **发送消息**: 向Chain发送消息，系统自动按顺序传递给节点处理
5. **退出处理**: 向Chain发送`Macro: Exit`消息，所有节点会依次退出

### 使用API

`CSM - Mark As Chain Module.vi`用于生成责任链模式的节点名称：

- **输入**: 
  - CSM Name - 如`Handler`
  - Order - 节点顺序编号，如`1`、`2`、`3`
- **输出**: CSM Name (Marked As Chain) - 如`Handler$1`

注意：Order编号不必连续，但必须唯一。编号小的节点排在链条前面，优先处理消息。

### 节点能力定义

每个链节点需要明确定义自己能处理哪些消息。未定义的消息会自动传递给下一个节点。通常的实现方式：

1. 在节点的case结构中只实现能处理的状态
2. 其他消息会触发"Default"分支，CSM会自动传递给下一个节点
3. 如果所有节点都无法处理，最终返回错误

### 与工作者模式的区别

| 特性 | 工作者模式 | 责任链模式 |
|------|-----------|-----------|
| 消息分配 | 空闲Worker处理 | 按顺序传递 |
| 处理能力 | 所有Worker能力相同 | 每个节点能力不同 |
| 并发性 | 高并发处理 | 顺序处理 |
| 适用场景 | 相同任务并发 | 不同任务串行 |
| 带界面 | 不适合 | 可以使用 |

### 注意事项

- 不能直接向单个Chain Node发送消息，必须通过Chain名称
- 节点顺序很重要，设计时需要仔细考虑
- 每个节点应该只处理明确定义的消息
- 链条过长可能影响消息处理效率

### 参考范例

可参考范例：`4. Advance Examples\2. Chain of Responsibility Example`

## 多循环模式支持

多循环模式是CSM的另一个重要特性，允许一个CSM模块包含多个并行运行的循环。这种模式适用于需要将通讯逻辑与功能逻辑分离的场景。

### 应用场景

多循环模式适用于以下场景：

1. **改造现有代码**: 在已有的功能循环（如TCP连接循环、DAQmx采集循环）外围添加CSM通讯循环，避免重构现有逻辑

2. **实时性要求**: 需要使用定时循环（Timed Loop）的场景，功能循环保证实时性，CSM循环处理通讯

3. **复杂界面**: 界面操作非常复杂时，将界面循环与功能循环分离，提高响应性

4. **连续采集**: 需要连续采集数据的场景，采集循环不能被打断，CSM循环处理控制命令

### 核心API

#### CSM - Request CSM to Post Message.vi

在多循环模式下，非CSM循环可以通过此API请求CSM循环发送消息。

**特点**：
- 可以指定消息立即执行，优先于队列中的其他消息
- 支持异步消息，可以获取返回值
- 相比`CSM - Post Message VI`，发送时机更可控

**参数**：
- Module Name: CSM模块名称
- State: 消息名称
- Arguments: 消息参数
- Without Reply?: 是否需要返回（F=有返回，T=无返回）
- Target Module: 目标模块名称
- Immediately?: 是否立即执行（T=优先处理）

#### CSM - Request CSM to Broadcast Status Change.vi

在多循环模式下，非CSM循环可以通过此API请求CSM循环发送广播。

**注意**：此API仅应在模块内部使用，不要在外部伪装其他模块发送广播。

**参数**：
- Module Name: 发送广播的CSM模块名称
- Status: 广播名称
- Arguments: 广播参数
- Broadcast?: 是否发送广播
- Priority: 广播优先级（Status/Interrupt）
- Immediately?: 是否立即执行

#### CSM - Forward UI Operations to CSM.vi

将UI循环中的用户操作转发到CSM循环处理。这是DQMH-Style模板使用的核心机制。

**参数**：
- State(s) In: 待处理的状态
- Name: CSM模块名称
- High Priority?: 是否高优先级处理

#### CSM - Module Turns Invalid.vi

检查CSM模块是否已经退出，用于功能循环跟随CSM循环退出。

**注意**：高级模式（协作者、责任链）的模块只有在最后一个节点退出后才触发退出事件。

### 设计模式

多循环模式通常包含以下循环结构：

1. **CSM循环**: 处理模块间通讯和控制逻辑
2. **功能循环**: 执行实际的功能代码（采集、处理等）
3. **UI循环**（可选）: 处理用户界面事件

循环间通过队列、用户事件等机制进行数据交互。

### 参考范例

- `4. Advance Examples\5. Multi-Loop Module Example\TCP Server Module(Multi-Loop Support).vi`
- `Addons - Loop Support\CSMLS - Continuous Loop in CSM Example.vi`

## 总结

CSM的高级模式和特性为复杂应用提供了强大的支持：

- **错误处理机制**: 提供统一的错误捕获和处理
- **系统级模块**: 实现系统服务与业务逻辑的分离
- **子模块**: 通过命名实现模块的逻辑分组
- **工作者模式**: 实现任务的并发处理和负载均衡
- **责任链模式**: 实现消息的顺序处理和功能组合
- **多循环支持**: 实现复杂场景下的循环分离和协作

这些特性相互补充，可以灵活组合使用，构建出高性能、高可维护性的LabVIEW应用系统。
